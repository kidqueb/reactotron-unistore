{"version":3,"file":"index.mjs","sources":["../src/helpers.js","../src/index.js","../src/createCommandHandlers.js"],"sourcesContent":["export const ROOT_VALS = [\"\", \"*\", \".*\", \"root\", \"root.*\"];\n\n/**\n * @name getChanges\n * For each path we're subscribed to, get the values after the latest state change.\n * @param {array} paths\n * @param {object} state\n * @param {array} changes\n */\nexport function getChanges(paths = [], state = {}, changes = []) {\n  if (paths.length === 0) return changes;\n\n  for (let index = 0, total = paths.length; index < total; index++) {\n    const path = paths[index];\n    const value = getPathState(path, state);\n\n    if (value) changes.push({ path, value });\n  }\n\n  return changes;\n}\n\n/**\n * @name getActionValues\n * Since we recieve a function instead of a redux structured action object\n * we have to call the function to get the object it returns in order to\n * determine what the params may have been. Kind've assumes it's just\n * setting state recieved instead of executing calls based on params =/\n * @param {object} state\n * @param {function} action\n */\nexport async function getActionValues(state, action) {\n  if (!action) return false;\n\n  const actionResponse = await action()\n  const actionKeys = actionResponse ? Object.keys(actionResponse) : [];\n\n  let actionValues = {};\n  for (let index = 0; index < actionKeys.length; index++) {\n    const key = actionKeys[index];\n    actionValues[key] = state[key];\n  }\n\n  return actionValues;\n}\n\n/**\n * @name getPathState\n * Calls getPathObj to get the state at a specific path, but accounts for\n * our root keywords and actual path since idk if getPathObj can use .* ha\n * @param {string} path\n * @param {object} state\n */\nexport function getPathState(path, state) {\n  return isPathRoot(path) ? state : getPathObj(state, path);\n}\n\n/**\n * @name getPathObj\n * Get the value/object at a specific path in the state tree.\n * Completely ripped off from https://github.com/infinitered/reactotron-redux\n * @param {object} state\n * @param {string} path\n */\nexport function getPathObj(state, path) {\n  if (!path) return state;\n  const splitPaths = path.split(\".\");\n\n  let pathObj = state;\n  for (let i = 0; i < splitPaths.length; i++) {\n    const currentPath = splitPaths[i];\n    if (currentPath !== \"*\") pathObj = pathObj[currentPath];\n\n    if (i < splitPaths.length - 1 && typeof pathObj !== \"object\") {\n      pathObj = undefined;\n      break;\n    }\n  }\n\n  return pathObj;\n}\n\n/**\n * @name isPathRoot\n * Determines if the path is one of our predetermined root paths.\n * @param {string} path\n */\nexport function isPathRoot(path) {\n  return ROOT_VALS.indexOf(path) > -1;\n}\n","import createCommandHandlers from \"./createCommandHandlers\";\n\nexport default store => {\n  return reactotron => {\n    const handlers = createCommandHandlers(store, reactotron);\n\n    return {\n      onCommand: res => {\n        const handler = handlers[res.type];\n        handler && handler(res);\n      }\n    };\n  };\n};\n","import { getPathState, getChanges, getActionValues } from \"./helpers\";\n\nexport default function createCommandHandlers(store, reactotron) {\n  let storeSub,\n    clientSubs = [];\n  const restoreState = store.action((_, state) => state);\n\n  return {\n    \"state.keys.request\": ({ payload }) => {\n      const state = getPathState(payload.path, store.getState());\n      reactotron.stateKeysResponse(payload.path, Object.keys(state));\n    },\n\n    \"state.values.request\": ({ payload }) => {\n      const state = getPathState(payload.path, store.getState());\n      reactotron.stateValuesResponse(payload.path, state);\n    },\n\n    \"state.values.subscribe\": ({ payload }) => {\n      clientSubs = payload.paths;\n\n      // handle initial paths from the client\n      if (payload.paths) {\n        const changes = getChanges(clientSubs, store.getState());\n        reactotron.stateValuesChange(changes);\n      }\n\n      // subscribe to handle changes to our subscribed paths\n      if (!storeSub)\n        store.subscribe((state, action) => {\n          const name = (action && action.name) || \"Reactotron/DISPATCH\";\n          const changes = getChanges(clientSubs, state);\n\n          getActionValues(state, action).then(actionValues => {\n            if (actionValues) {\n              reactotron.stateActionComplete(name, actionValues);\n            } else {\n              reactotron.display({\n                name: \"UNISTORE\",\n                preview: \"store.setState\",\n                value:\n                  \"Warning: The values of the action cannot be determined when store.setState is used to update state within an action. Think about returning an object instead.\",\n                important: true\n              });\n            }\n\n            reactotron.stateValuesChange(changes);\n          });\n        });\n    },\n\n    \"state.action.dispatch\": ({ payload }) => {\n      store.setState(payload.action);\n    },\n\n    \"state.backup.request\": () => {\n      const state = store.getState();\n      reactotron.stateBackupResponse(state);\n    },\n\n    \"state.restore.request\": ({ payload }) => {\n      restoreState(payload.state);\n    }\n  };\n}\n"],"names":["ROOT_VALS","getChanges","paths","state","changes","length","index","total","path","value","getPathState","push","indexOf","isPathRoot","splitPaths","split","pathObj","i","currentPath","undefined","getPathObj","store","reactotron","handlers","storeSub","clientSubs","restoreState","action","_","state.keys.request","payload","getState","stateKeysResponse","Object","keys","state.values.request","stateValuesResponse","state.values.subscribe","stateValuesChange","subscribe","name","actionResponse","actionKeys","actionValues","key","getActionValues","then","stateActionComplete","display","preview","important","state.action.dispatch","setState","state.backup.request","stateBackupResponse","state.restore.request","createCommandHandlers","onCommand","res","handler","type"],"mappings":"MAAaA,EAAY,CAAC,GAAI,IAAK,KAAM,OAAQ,mBASjCC,EAAWC,EAAQ,GAAIC,EAAQ,GAAIC,EAAU,IAC3D,GAAqB,IAAjBF,EAAMG,OAAc,OAAOD,EAE/B,IAAK,IAAIE,EAAQ,EAAGC,EAAQL,EAAMG,OAAQC,EAAQC,EAAOD,IAAS,CAChE,MAAME,EAAON,EAAMI,GACbG,EAAQC,EAAaF,EAAML,GAE7BM,GAAOL,EAAQO,KAAK,CAAEH,KAAAA,EAAMC,MAAAA,IAGlC,OAAOL,EAkCT,SAAgBM,EAAaF,EAAML,GACjC,gBAiCyBK,GACzB,OAAOR,EAAUY,QAAQJ,IAAS,EAlC3BK,CAAWL,GAAQL,EAU5B,SAA2BA,EAAOK,GAChC,IAAKA,EAAM,OAAOL,EAClB,MAAMW,EAAaN,EAAKO,MAAM,KAE9B,IAAIC,EAAUb,EACd,IAAK,IAAIc,EAAI,EAAGA,EAAIH,EAAWT,OAAQY,IAAK,CAC1C,MAAMC,EAAcJ,EAAWG,GAG/B,GAFoB,MAAhBC,IAAqBF,EAAUA,EAAQE,IAEvCD,EAAIH,EAAWT,OAAS,GAAwB,iBAAZW,EAAsB,CAC5DA,OAAUG,EACV,OAIJ,OAAOH,EAzB2BI,CAAWjB,EAAOK,kBCpDvCa,GACNC,IACL,MAAMC,WCFoCF,EAAOC,GAC/CE,IACFC,EAAa,GACf,MAAMC,EAAeL,EAAMM,OAAO,CAACC,EAAGzB,IAAUA,GAEhD,MAAO,CACL0B,qBAAsB,EAAGC,QAAAA,MACvB,MAAM3B,EAAQO,EAAaoB,EAAQtB,KAAMa,EAAMU,YAC/CT,EAAWU,kBAAkBF,EAAQtB,KAAMyB,OAAOC,KAAK/B,KAGzDgC,uBAAwB,EAAGL,QAAAA,MACzB,MAAM3B,EAAQO,EAAaoB,EAAQtB,KAAMa,EAAMU,YAC/CT,EAAWc,oBAAoBN,EAAQtB,KAAML,IAG/CkC,yBAA0B,EAAGP,QAAAA,MAI3B,GAHAL,EAAaK,EAAQ5B,MAGjB4B,EAAQ5B,MAAO,CACjB,MAAME,EAAUH,EAAWwB,EAAYJ,EAAMU,YAC7CT,EAAWgB,kBAAkBlC,GAI/BiB,EACQkB,UAAU,CAACpC,EAAOwB,KACtB,MAAMa,EAAQb,GAAUA,EAAOa,MAAS,sBAClCpC,EAAUH,EAAWwB,EAAYtB,aFAXA,EAAOwB,OAC3C,OAAKA,kBAEwBA,mBAAvBc,GACN,MAAMC,EAAaD,EAAiBR,OAAOC,KAAKO,GAAkB,GAElE,IAAIE,EAAe,GACnB,IAAK,IAAIrC,EAAQ,EAAGA,EAAQoC,EAAWrC,OAAQC,IAAS,CACtD,MAAMsC,EAAMF,EAAWpC,GACvBqC,EAAaC,GAAOzC,EAAMyC,GAG5B,OAAOD,qBAXa,GADtB,oCEEUE,CAAgB1C,EAAOwB,GAAQmB,KAAKH,IAC9BA,EACFrB,EAAWyB,oBAAoBP,EAAMG,GAErCrB,EAAW0B,QAAQ,CACjBR,KAAM,WACNS,QAAS,iBACTxC,MACE,gKACFyC,WAAW,IAIf5B,EAAWgB,kBAAkBlC,QAKrC+C,wBAAyB,EAAGrB,QAAAA,MAC1BT,EAAM+B,SAAStB,EAAQH,SAGzB0B,uBAAwB,KACtB,MAAMlD,EAAQkB,EAAMU,WACpBT,EAAWgC,oBAAoBnD,IAGjCoD,wBAAyB,EAAGzB,QAAAA,MAC1BJ,EAAaI,EAAQ3B,SDzDNqD,CAAsBnC,EAAOC,GAE9C,MAAO,CACLmC,UAAWC,IACT,MAAMC,EAAUpC,EAASmC,EAAIE,MAC7BD,GAAWA,EAAQD"}